breed [producers producer]

globals[fake0]

producers-own [
  name ; name of the producer
  kind ; difference between bigProducer [1] and smallProducer [-1]
  capacity ;
  marginal_cost
  quality_product
  innovation
  advertising
  efficiency
  price
  profit
  new_profit
  quantity_sold
  quantity_left
  new_quantity_sold
  invest?
  profit_post
  efficiency_post
  advertising_post
  quality_product_post
  mc_post
  price_post
  innovation_post
  incentive
  x_cor
  Bi
  nameBig 
]
to evaluate
 
  
end
to NewTechnology
  ; I compute the new marginal cost after the innovation {mc_post}
  ; Each firm forecasts the market share {random(quantity_left)} It could gain from reducing its price 
  ; I compute the incentives to innovate for each firm
 
  ask producers[
    if marginal_cost > 1[
     set efficiency_post efficiency + (Technologycost / 100)
     set innovation_post innovation + (Technologycost / 200)
     set mc_post quality_product + innovation_post + advertising - efficiency_post 
     ]
     if quantity_sold < capacity[
       set quantity_sold quantity_sold + random (quantity_left)                 
       set profit_post (price - mc_post) * quantity_sold
       type "Profit Post" show profit_post
       type "Profit Ante" show profit
       ifelse profit_post != 0 [
       set incentive (profit_post - profit) / (profit_post)][                         
       set incentive 0]
       type "Incentives: "show incentive
     ]
     ]
     
     let producers_list sort producers with [quantity_sold < capacity]
     let incentives_list []
     foreach producers_list[
       set incentives_list lput [incentive] of ?  incentives_list]   
     type "incentives list" print incentives_list
     let max_incentive max incentives_list
     let maxinc []
     let act_i 0
     foreach incentives_list[
       if ? = max_incentive [
         set maxinc lput act_i maxinc]
       set act_i act_i + 1
     ]
     
     let investor_index one-of maxinc
     let investor item investor_index producers_list
     show investor
     ask investor[
       set marginal_cost mc_post
       set invest? "Yes" 
       set innovation innovation_post
       set efficiency efficiency_post]
       

;  ask producers with [invest? = "Yes"] [show who] 
;  type "Profit List: " print profit_list
;  type "Max_profit: " print max_profit  
  
  
;  type "Mc list: " print mc_list
;  type "Max mc: " print max_mc
;  show producers with [invest? = "yes"]

      
  end     

to AdvertisingCampaign
  
   ask producers[
      let investors_list sort producers with [quantity_left > 0]
      set advertising_post advertising + (AdvCost / 50)
      type "advertising post " show advertising_post
      set mc_post marginal_cost + (advertising_post - advertising) * 0.6 
      set price_post price + mc_post - marginal_cost
      ifelse advCost <= 100 [
      if quantity_left > 0[
        set advertising advertising_post
        set marginal_cost mc_post
        set price price_post
        show who]
      ]
      [if quantity_left > 0 and kind = 1 [
          set advertising advertising_post
          set marginal_cost mc_post
          set price price_post
          show who]
      ]
   ]
   
end

to HumanCapital
  ask producers[
      set quality_product_post quality_product + (HumCapCost / 50)
      set mc_post marginal_cost + (quality_product_post - quality_product) * 0.6 
      set price_post price + (mc_post - marginal_cost)
      let quality_list [] 
      let investors_list sort producers with [quantity_left > 0]
      foreach investors_list[
      set quality_list lput [quality_product] of ? quality_list]
      let max_quality max quality_list
     let maxq []
     let act_i 0
     foreach quality_list[
       if ? = max_quality [
         set maxq lput act_i maxq]
       set act_i act_i + 1
     ]
     let investor_index one-of maxq
     let investor item investor_index investors_list
     
      ask investor [
      set quality_product quality_product_post
      set marginal_cost mc_post
      set price price_post
        show who]
   
      
  ]
   
  
end

to Producer_calc_new_profit
  ask producers[
    ;type "Old Profit" show profit
    set new_profit precision((price - marginal_cost) * quantity_sold)2
    ;type "New profit " show new_profit
  ]
end

to Producer_price_correction
  ask producers [
    ;type "Old price: " type price  
    if Quantity_sold < capacity [
      if price - 1 > marginal_cost [
        set price price - 1
      ]
    ]
    ;type " - New Price: " show price
  ]   
end

to Producer_new_tick
  ask producers[
    set profit new_profit
    set quantity_sold 0
    set quantity_left capacity
  ]
end

to Producer_setup  
  create-producers BigProducers [
    set size P_large_shape
    set kind 1
  ]
  create-producers SmallProducers [
    set size P_medium_shape
    set kind -1
  ]
  set fake0 10
  set demand HowManyConsumers?
  let ResidualDemand round (0.3 * demand)
    
  ;type "Demand: " print demand
  ;type "ResidualDemand: " print ResidualDemand
  
  set mi 0
  set product_list []
  ask producers [
    set shape "factory"
    set profit 0
        
    
    ;; set capacity vuale according to the kind of the producer: if Bigproducer set only the second term, otherwise set only the first                                                                                 
    set capacity (abs (1 - kind)) / 2 * ( round (ResidualDemand / SmallProducers) + random (21) ) + (abs(1 + kind)) / 2 *( round((0.7 * demand) / BigProducers) + random (31)) 
  
      
    ;type "Capacity for " show capacity
    ;; -----------------------------------
    ;; MODEL FIRMS' HETEOROGENEITY:
    ;; - different marginal costs
    ;; - different fixed costs
    ;; - different investments in advertising and innovation
    ;; - different prices
    ;; - different quality
    ;; Each attribute differs according to the capacity of the firm 
    ;;  => Ex: Big capacity => low marginal costs, 
    ;;                         higher investments in advertising (and innovation)
    ;;                         low quality
    ;;                         low price
    ;; -----------------------------------
   
    ifelse kind = 1 [           
        set innovation random-normal innovation_mean_Big innovation_SD_Big             
        set advertising random-normal advertising_mean_Big advertising_SD_Big 
        set quality_product random-normal quality_mean_big quality_SD_Big 
        set efficiency random-normal efficiency_mean_big efficiency_SD_big
        set marginal_cost innovation + advertising + quality_product - efficiency              
        set price (marginal_cost +  random (20)) 
        ] 
    [ 
    ;; Kind =  - 1        
        set advertising  random-normal advertising_mean advertising_SD         
        set innovation random-normal innovation_mean innovation_SD
        set quality_product random-normal quality_mean quality_SD 
        set efficiency random-normal efficiency_mean efficiency_SD
        set marginal_cost advertising + innovation + quality_product - efficiency              
        set price marginal_cost +  random (10)      
      ]
    set mc_list []
    set mc_list lput marginal_cost mc_list
    set min_mc min mc_list
    
    ;show price
    set name  mi
   if kind = -1[
    set mi mi + 1]
   
    set product_list lput self product_list
    
    let BigPro []
    set BigPro filter [[kind] of ? = 1] product_list
    ;type "Big_pro" print bigPro
    
    set Bi 1
    foreach BigPro[
      set nameBig Bi + (SmallProducers)
      set Bi Bi + 1]
   
     ifelse kind = -1[
      setxy (setX name) (setY price)][
      setxy (setX nameBig) (setY price)
      ]
  ]
end

to-report setY [p]
  report max-pycor / 60 * p 
end

to-report setX [n]
      set x_cor round(600 / (BigProducers + SmallProducers + 1))
      report (fake0  + n * x_cor)
end

to-report setX_big [nB]
  set x_cor round(600 / (BigProducers + SmallProducers + 1))
  report (fake0 + nB * x_cor)
end

