breed [producers producer]

globals[fake0]

producers-own [
  name ; name of the producer
  kind ; difference between bigProducer [1] and smallProducer [-1]
  MaxCapacity ;
  marginal_cost
  quality_product
  innovation
  advertising
  efficiency
  price
  profit
  new_profit
  quantity_sold
  quantity_left
  new_quantity_sold
  invest?
  profit_post
  efficiency_post
  advertising_post
  quality_product_post
  mc_post
  price_post
  innovation_post
  incentive
  equity
]



to NewTechnology
  ; I compute the new marginal cost after the innovation {mc_post}
  ; Each firm forecasts the market share {random(quantity_left)} It could gain from reducing its price 
  ; I compute the incentives to innovate for each firm
 
  ask producers[
    if marginal_cost > 1[
     set efficiency_post efficiency + (Technologycost / 100)
     set innovation_post innovation + (Technologycost / 200)
     set mc_post quality_product + innovation_post + advertising - efficiency_post 
     ]
     if quantity_left > 0 [
       set quantity_sold quantity_sold + random (quantity_left)                 
       set profit_post (price - mc_post) * quantity_sold
       ;type "Profit Post" show profit_post
       ;type "Profit Ante" show profit
       ifelse profit_post != 0 [
       set incentive (profit_post - profit) / (profit_post)][                         
       set incentive 0]
       ;type "Incentives: "show incentive
     ]
     ]
     
     let producers_list sort producers with [quantity_left > 0]
     let incentives_list []
     foreach producers_list[
       set incentives_list lput [incentive] of ?  incentives_list]   
     type "incentives list" print incentives_list
     let max_incentive max incentives_list
     let maxinc []
     let act_i 0
     foreach incentives_list[
       if ? = max_incentive [
         set maxinc lput act_i maxinc]
       set act_i act_i + 1
     ]
     
     let investor_index one-of maxinc
     let investor item investor_index producers_list
     ;show investor
     ask investor[
       set marginal_cost mc_post
       set invest? "Yes" 
       set innovation innovation_post
       set efficiency efficiency_post]
       

;  ask producers with [invest? = "Yes"] [show who] 
;  type "Profit List: " print profit_list
;  type "Max_profit: " print max_profit  
  
  
;  type "Mc list: " print mc_list
;  type "Max mc: " print max_mc
;  show producers with [invest? = "yes"]

      
  end     

to AdvertisingCampaign
  
   ask producers[
      let investors_list sort producers with [quantity_left > 0]
      set advertising_post advertising + (AdvCost / 50)
      ;type "advertising post " show advertising_post
      set mc_post marginal_cost + (advertising_post - advertising) * 0.6 
      set price_post price + mc_post - marginal_cost
      ifelse advCost <= 100 [
      if quantity_left > 0[
        set advertising advertising_post
        set marginal_cost mc_post
        set price price_post
        show who]
      ]
      [if quantity_left > 0 and kind = 1 [
          set advertising advertising_post
          set marginal_cost mc_post
          set price price_post
          show who]
      ]
   ]
   
end

to HumanCapital
  ask producers[
      set quality_product_post quality_product + (HumCapCost / 50)
      set mc_post marginal_cost + (quality_product_post - quality_product) * 0.6 
      set price_post price + (mc_post - marginal_cost)
      let quality_list [] 
      let investors_list sort producers with [quantity_left > 0]
      foreach investors_list[
      set quality_list lput [quality_product] of ? quality_list]
      let max_quality max quality_list
     let maxq []
     let act_i 0
     foreach quality_list[
       if ? = max_quality [
         set maxq lput act_i maxq]
       set act_i act_i + 1
     ]
     let investor_index one-of maxq
     let investor item investor_index investors_list
     
      ask investor [
      set quality_product quality_product_post
      set marginal_cost mc_post
      set price price_post
        show who]
   
      
  ]
   
  
end

to Producer_calc_new_profit
  ask producers[
    ;type "Old Profit" show profit
    set new_profit precision((price - marginal_cost) * quantity_sold)2
    ;type "New profit " show new_profit
    set equity equity + new_profit
    ;type "Equity" show equity 
    
    set equity_list []
    foreach product_list [
    set equity_list lput [equity] of ? equity_list]
    set max_equity max equity_list
  ]

  ;type "equity list" show sort equity_list
end

to Producer_price_correction
  ask producers [
    ;type "Old price: " type price  
    if Quantity_left > 0 [
      if price - 1 > marginal_cost [
        set price price - 1
      ]
    ]
    if quantity_left = 0 [
      set price price + 1]
    ;type " - New Price: " show price
  ]   
end

to Producer_new_tick
  ask producers[
    set profit new_profit
    set quantity_sold 0
    set quantity_left Maxcapacity
  ]
end

to grow
  ask producers[
    if ticks > 20 and ticks < 50 [
     set size size + equity / max_equity
     ]
    if ticks > 50 [  
      if size >= 40 [
         if maxcapacity < (0.6 * Demand) / (count producers with [size >= 40])[
           set maxcapacity maxcapacity + random (5)
           set advertising advertising + 0.4
           set innovation innovation + 0.4
           set efficiency efficiency + 0.6]
             if quality_product >= 2[
              set quality_product  quality_product - 0.4
              ]
             ]
         ]
         ]
         
    
      
    
  
end
to Producer_setup  
  create-producers HowManyProducers 
  set fake0 10
  set demand HowManyConsumers?
  let ResidualDemand round (0.3 * demand)
    
  ;type "Demand: " print demand
  ;type "ResidualDemand: " print ResidualDemand
  
  set mi 0
  set product_list []
  ask producers [
    
    set profit 0
    set equity profit
 
        
    
    ;; set capacity vuale according to the kind of the producer: if Bigproducer set only the second term, otherwise set only the first                                                                                 
    ;set capacity (abs (1 - kind)) / 2 * ( round (ResidualDemand / SmallProducers) + random (21) ) + (abs(1 + kind)) / 2 *( round((0.7 * demand) / BigProducers) + random (31)) 
     set MaxCapacity round (Demand / (HowManyProducers)) + 0.05 * Demand
      
    ;type "Capacity for " show capacity
    ;; -----------------------------------
    ;; MODEL FIRMS' HETEOROGENEITY:
    ;; - different marginal costs
    ;; - different fixed costs
    ;; - different investments in advertising and innovation
    ;; - different prices
    ;; - different quality
    ;; Each attribute differs according to the capacity of the firm 
    ;;  => Ex: Big capacity => low marginal costs, 
    ;;                         higher investments in advertising (and innovation)
    ;;                         low quality
    ;;                         low price
    ;; -----------------------------------
             
        set innovation random-normal innovation_mean innovation_SD             
        set advertising random-normal advertising_mean advertising_SD 
        set quality_product random-normal quality_mean quality_SD 
        set efficiency random-normal efficiency_mean efficiency_SD
        if efficiency > (innovation + advertising + quality_product )[
          set efficiency (innovation + advertising + quality_product - 1) ]
        set marginal_cost innovation + advertising + quality_product - efficiency              
        set price (marginal_cost +  random (20)) 
        set price_list []
        set price_list lput price price_list
        set max_price max price_list
        
        ;type "Price" show price
        

    set mc_list []
    set mc_list lput marginal_cost mc_list
    set min_mc min mc_list
       
    set product_list lput self product_list
    
;    let BigPro []
;    set BigPro filter [[kind] of ? = 1] product_list
;    ;type "Big_pro" print bigPro
;    
;    set Bi 1
;    foreach BigPro[
;      set nameBig Bi + (SmallProducers)
;      set Bi Bi + 1]
;   
      set name mi
      set mi mi + 1
      setxy (setX name) (setY price)]
end

to-report setY [p]
  report max-pycor / 100 * p 
end

to-report setX [n]
      set x_cor round( max-pxcor / (HowManyProducers + 1))
      report (fake0  + n * x_cor)
end

to-report setXpost [eq]
  if ticks >= 20[
      set x_cor round ( max-pxcor / max_equity)
      report (fake0 + eq * x_cor)]
  end 


