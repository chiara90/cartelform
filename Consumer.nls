breed [consumers consumer]

consumers-own
[ name
  age
  educational_level
  professional_level
  social_class 
  affordable_products
  innovativeness
  conditioning
  imitation
  quality
  reservation_price
  purchase
  greed
]

to setup-consumers
  create-consumers HowManyConsumers? [set size 10]
  set ni 0
  ask consumers [
  
    set shape "person"
    setxy random (600) 600            ;; greater concentration in the center?
    set age random (90)
    ;; edu_level can assume              
    ;; 0 => nothing                          
    ;; 1 => elementary school            
    ;; 2 => primary school               
    ;; 3 => secondary school             
    ;; 4 => bachelor degree                  
    ;; 5 => master degree
    ;; professional_level can assume
    ;; 0 => nothing
    ;; 1 => student
    ;; 2 => unemployed
    ;; 3 => employed
    ;; 4 => professionist
    ;; 5 => manager
    ifelse age >= 24 [
      set educational_level 2 + random(4) 
      set professional_level random (6)
    ] [ 
      ifelse age >= 22 [ 
        set educational_level 2 + random(3)
        set professional_level random (5)
      ] [ 
        ifelse age >= 19 [ 
          set educational_level 2 + random(2) 
          set professional_level random(4)
        ] [ 
          ifelse age >= 14 [ 
            set educational_level 2 
            set professional_level 1
          ] [ 
            ifelse age >= 11 [ 
              set educational_level 1 
              set professional_level 1
            ] [ 
              set educational_level 0 
              set professional_level 0
            ]
          ]
        ]
      ]
    ]
    ;; social class can assume:
    ;; 0 => proletariat
    ;; 1=> middle-class
    ;; 2 =>upper-class
    
    set social_class random  (3)  
    ifelse age > 50  [
      set innovativeness random (1)
    ] [
      set innovativeness random (2)
    ]
    
    ;; TO DO find a better formula to calculate the reservation_price: Professional_level goes from 0 to 5; Social_class from 1 to 3: Max reservation_price = 5 * 9 + 30 = 75
    set reservation_price min_mc + professional_level * (social_class + 1) * 3 + random(30)
    set conditioning precision (1 + random-float (3))2
    set quality precision (1 + random-float (3))2 
    set imitation precision (1 + random-float (3))2
    set greed precision( 1 + random-float (3))2
   

    set ni ni  + 1
      set name ni
       ;type "name" show ni
 ]

end

to find_best_producer

  ask consumers[
    set affordable_products filter [ [price] of ? <= reservation_price and [quantity_left] of ? > 0  ] product_list
    if empty? affordable_products [
      set purchase 0
      ;type "Purchase? " show purchase
       
      stop
    ]
    ; type "reservation price =>" print reservation_price
    ; show affordable_products
    let price_AP []
    let quality_AP []
    let innovation_AP []
    let advertising_AP []

    let score_price_AP []
    let score_quality_AP []
    let score_innovation_AP []
    let score_advertising_AP []
    let total_score_AP []
    foreach affordable_products [
      let delta_price (reservation_price - [price] of ?)
      let score_price delta_price * greed
      let score_quality [quality_product] of ? * quality
      let score_innovation [innovation] of ? * innovativeness
      let score_advertising [advertising] of ? * conditioning
      let rank round (score_price + score_quality + score_innovation + score_advertising)
      set total_score_AP lput rank total_score_AP

    ]
      ;type "quality_affordable_products => " show quality_affordable_products
      ;type "innovation_affordable_products => " show innovation_affordable_products 
      ;type "advertising_affordable_products => " show advertising_affordable_products
     
      ;show total_score_AP
      
      ;type "total_score" show total_score
      
  
      let best_producer_index find_best_score total_score_AP
      
      set best_producer item best_producer_index affordable_products
      ask best_producer [
        set quantity_sold quantity_sold + 1 
        set quantity_left quantity_left - 1
        ;type "Quantity sold by " show quantity_sold
        ;type "Quanity Left for " show quantity_left
      ]
      set purchase 1
      ;type "The Best Producer is => " print best_producer
      ;create-link-with best_producer
    
      ;type "name" show name
      let consumer_list sort consumers
    
      if purchase > 0 [
      setxy ([xcor] of best_producer - 2 + random-float(15)) ([ycor] of best_producer + ([quantity_sold] of best_producer / 2))
      ]
      
      ;Type " Purchase? " show purchase  
     
  ]
end

to-report find_best_score [ts]
  let mscore max ts
  let maxs []
  let act_i 0
  foreach ts [
   if ? = mscore [
      set maxs lput act_i maxs
   ]
   set act_i act_i + 1 
  ]
  report one-of maxs
end 
